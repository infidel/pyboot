#!/usr/bin/env python
#
# pyboot: automatically load/boot kernel + DTB + initrd
#
# Automatically load and boot kernel image (and optionally load DTB
# and initrd) on <board> using netboot (DHCP + TFTP).  Images are
# copied to a temporary, TFTP-accessible location (unless already
# under TFTP root dir) so they can be loaded by <board> via TFTP.
# 
# Serial console and hardreset/power-down of <board> is handled
# through conmux.  Conmux provides the serial console, and also allows
# special escape that can run arbitrary commands and are useful for
# hardreset and power-off of target board.
#
# Reads config file from /etc/pyboot.conf, $PWD/.pyboot and ~/.pyboot
#
# Authors: Olof Johansson <olof@lixom.net>, Kevin Hilman <khilman@kernel.org>
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.
#
# TODO:
# - generalize bootargs: set by inserting into DTB, not only u-boot env
#   - needs to handle current post-dhcp init (via netargs)
# - cleanup: create an array of temp files that all get removed
#   in "finally"
#
import os, sys, time, stat, re
import pexpect, getopt, tempfile, shutil, subprocess
import ConfigParser
import json
import struct

def usage():
    name = os.path.basename(sys.argv[0])
    print
    print name, "[options] <board> [<kernel>[:addr]] [<dtb>[:addr]] [<initrd>[:addr]"
    print "  -h: this help message"
    print "  -d: enable debug mode"
    print "  -v: display verbose interaction with target"
    print "  -i: after kernel boots, enter interactive mode with serial console"
    print "  -u <addr>: create uImage from zImage with <addr> as load address"
    print "             (useful when u-boot is missing bootz support)"
    print "  -c <cmdline>: append on to kernel commandline"
    print "  -t: run tests defined in config file"
    print

verbose = False
interact = False
uimage_addr = 0
uimage_addr_default = 0x00008000
convert_uimage = False
shutdown = False  # shutdown/halt and poweroff board when done
cmdline_append = ""
debug = False
dry_run = False
quiet = False
prompt = ''
logfile = None
exp_logfile = None
run_tests = False
check_warnings = False
dhcp = True
dtb_append = None
dtb_modified = None

temp_files = []

try:
    opts, args = getopt.getopt(sys.argv[1:], "ac:dhil:qstu:vwy")

except getopt.GetoptError as err:
    print str(err) # will print something like "option -a not recognized"
    sys.exit(2)
for o, a in opts:
    if o == "-a":
        dtb_append = True
    elif o == "-c":
        cmdline_append = a
    elif o == "-d":
        debug = True
    elif o == "-y":
        dry_run = True
    elif o == "-h":
        usage()
        sys.exit(0)
    elif o == "-i":
        interact = True
    elif o == "-l":
        logfile = a
    elif o == "-s":
        shutdown = True
    elif o == "-q":
        quiet = True
    elif o == "-t":
        run_tests = True
    elif o == "-u":
        convert_uimage = True
        uimage_addr = a
    elif o == "-v":
        verbose = True
    elif o == "-w":
        check_warnings = True
    else:
        assert False, "unhandled option %s" %o
 
if len(args) < 1:
    usage()
    sys.exit(1)

board = args[0]
tftproot = '/tftpboot'
serverip = None
loadaddr = None
dtb = None
dtb_addr = None
initrd = None
initrd_size = 0
initrd_addr = None
initrd_cmdline = False
initrd_uboot = None
initrd_uboot_tmp = None
uboot_env = None
uboot_early = None
post_reset_ctrl = None
log_prefix = 'boot-%s' %board
if not logfile:
    logfile = "%s.log" %log_prefix
start_time = 0
boot_time = 0
fastboot = False
warnings = 0
boot_meta = {}

config = ConfigParser.ConfigParser()
config.read(['/etc/pyboot.conf', os.path.expanduser('~/.pyboot'), '.pyboot'])

section = 'DEFAULT'
if config.has_section(board):
    section = board

if debug:
    for item in config.items(section):
        print item

# Config file options
if config.has_option(section, 'serverip'):
    serverip = config.get(section, 'serverip')
if config.has_option(section, 'tftproot'):
    tftproot = config.get(section, 'tftproot')
if config.has_option(section, 'image'):
    kimage = config.get(section, 'image')
if config.has_option(section, 'dtb'):
    dtb = config.get(section, 'dtb')
if config.has_option(section, 'initrd'):
    initrd = config.get(section, 'initrd')
if config.has_option(section, 'uboot_env'):
    uboot_env = config.get(section, 'uboot_env')
if config.has_option(section, 'uboot_early'):
    uboot_early = config.get(section, 'uboot_early')
if uimage_addr == 0 and config.has_option(section, 'uimage_addr'):
    uimage_addr = config.get(section, 'uimage_addr')
    convert_uimage = True
if config.has_option(section, 'uimage_addr_default'):
    uimage_addr_default = int(config.get(section, 'uimage_addr_default'), 16)
if config.has_option(section, 'dhcp'):
    dhcp = config.getboolean(section, 'dhcp')
if config.has_option(section, 'fastboot'):
    fastboot = config.get(section, 'fastboot')
if config.has_option(section, 'post_reset_ctrl'):
    post_reset_ctrl = config.get(section, 'post_reset_ctrl')

if len(args) > 1:
    kimage = args[1]
if len(args) > 2:
    dtb = args[2]
if len(args) > 3:
    initrd = args[3]

def path_addr_split(path):
    """Split the argument (of the form path[:addr] into (path, addr)"""
    addr = None
    if path == '-':
        return (None, None)
    if path.find(':') != -1:
        (path, addr) = path.split(':')
    if not os.path.exists(path):
        print "ERROR: file", path, "does not exist."
        sys.exit(1)
    return (path, addr)

(kimage, loadaddr) = path_addr_split(kimage)
if not loadaddr:
    if config.has_option(section, 'loadaddr'):
        loadaddr = config.get(section, 'loadaddr')
    else:
        loadaddr = '${loadaddr}' # use u-boot env 
if dtb:
    (dtb, dtb_addr) = path_addr_split(dtb)
    if not dtb_addr:
        if config.has_option(section, 'dtb_append'):
            dtb_append = True
            dtb_addr = ''
        elif config.has_option(section, 'dtb_addr'):
            dtb_addr = config.get(section, 'dtb_addr')
        else:
            dtb_addr = '${fdtaddr}' # use u-boot env
if not dtb:
    dtb_addr = ''

if initrd:
    (initrd, initrd_addr) = path_addr_split(initrd)
    if initrd:
        initrd_size = os.path.getsize(initrd)
        if config.has_option(section, 'initrd_uboot'):
            initrd_uboot = config.getboolean(section, 'initrd_uboot')
    if not initrd_addr:
        if config.has_option(section, 'initrd_addr'):
            initrd_addr = config.get(section, 'initrd_addr')
        elif not fastboot:
            initrd_addr = '${initrdaddr}' # use u-boot env
        else:
            initrd_addr = ""

if not initrd:
    initrd_addr = ''

# Check endianness of zImage
endian = "little"
out = subprocess.check_output("file %s" %kimage, shell=True).strip()
f, magic = out.split(":", 1)
m = re.search(".*\((\w+)-endian\)", magic)
if m:
    endian = m.group(1)
boot_meta["endian"] = endian

if not quiet:
    print "Board:", board
    print "Kernel:", kimage, loadaddr, "(endian: %s)" %endian
    if initrd:
        print "initrd:", initrd, initrd_addr, initrd_size
    if dtb:
        print "DTB:", dtb, 
        if dtb_append:
            print "(appending to kernel image)"
            dtb_addr = ""
        else:
            print dtb_addr

def progress(str, log=False):
    global start_time, c
    if dry_run:
        return

    t = time.time() - start_time
    min = t / 60
    sec = t % 60
    timestamp = '[%02d:%02d]' %(min, sec)

    if log and c.logfile:
        c.logfile.write("\n# PYBOOT: %s\n" %str)

    if verbose:
        # target console output is already verbose enough, don't add to it
        return

    if not quiet:
        print '%s %s' %(timestamp, str)

def create_uimage(zimg, addr_str):
    """ Create uImage from zImage with @addr ad load address. """
    if not os.path.basename(zimg).startswith('z'):
        raise Exception('ERROR: need a zImage to create a uImage: %s' %zimg)

    # Check if 'addr' is hex.  If not, it might be path to System.map,
    # where look for _text symbol to determine load address
    try:
        addr = int(addr_str, 16)
        entry = addr
    except ValueError:
        if os.path.exists(addr_str):
            system_map = addr_str
            virt_text = subprocess.check_output('grep " _text" %s' %system_map, shell=True).split()[0]
            text_offset = '0x' + virt_text.replace('c', '0')
            addr = int(text_offset, 16)
            entry = addr
            print "uImage: determined load address (0x%08x) from %s." %(addr, system_map)
        elif addr_str == "xip":
            addr = int(loadaddr, 16)
            entry = addr + 64
            print "uImage: XIP mode: Setting uImage load addr to TFTP load addr 0x%08x (and entry point +64b)" %(addr)
        else:
            addr = uimage_addr_default
            entry = addr
            print "WARNING: uImage: Unable to determine load address from %s. Using default 0x%08x" %(addr_str, addr)

    fd, uimg = tempfile.mkstemp(suffix="-uImage")
    cmd = 'mkimage -A arm -O linux -T kernel -C none -a 0x%x -e 0x%x -n "Linux" -d %s %s > /dev/null' %(addr, entry, zimg, uimg)
    subprocess.call(cmd, shell=True)
    os.chmod(uimg, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)
    if not os.path.exists(uimg):
        raise Exception('Unable to create uImage.')
    else:
        progress("Convered zImage to uImage (load address = 0x%08x)" %addr)

    return uimg

def tftp_setup():
    """ Create temp TFTP location. """
    global tftpdir, tftprel

    tftptmp = os.path.join(tftproot, 'tmp')
    if not os.path.exists(tftptmp):
        os.mkdir(tftptmp)
    tftpdir = tempfile.mkdtemp(prefix='%s-' %board, dir=tftptmp)
    os.chmod(tftpdir, stat.S_IRWXU | stat.S_IXGRP | stat.S_IXOTH)
    tftprel = os.path.relpath(tftpdir, tftproot)

def tftp_relpath(path):
    """Copy file into tftproot for access via TFTP and return path.
    If path is already under tftproot, do not copy, just return
    relative path.
    """
    global tftpdir, tftprel

    if path.startswith(tftproot):
        # already in TFTP root, no need to copy, just drop TFTP root prefix
        path = path[len(tftproot)+1:]  
    else:
        shutil.copy(path, tftpdir)
        path = os.path.join(tftprel, os.path.basename(path))
        
    return path

def tftp_cleanup():
    global tftpdir

    if tftpdir:
        shutil.rmtree(tftpdir)
        tftpdir = None

def do_report(retval=0, result=None):
    global start_time, c, boot_meta

    boot_time = time.time() - start_time
    if not result:
        if retval:
            result = 'FAIL'
        else:
            result = 'PASS'
    
    if not quiet:
        print "# PYBOOT: Time: %.2f" %boot_time
        if warnings:
            print "# PYBOOT: Warnings: %d" %warnings
        print "# PYBOOT: Result: %s" %result

    if c.logfile:
        c.logfile.write("# PYBOOT: Time: %.2f seconds.\n" %boot_time)
        if warnings:
            c.logfile.write("# PYBOOT: Warnings: %d\n" %warnings)
        c.logfile.write("# PYBOOT: Result: %s\n" %result)

    boot_meta["boot_time"] = round(boot_time, 2)
    boot_meta["boot_result"] = result
    boot_meta["boot_warnings"] = warnings
    boot_meta["boot_log"] = logfile

    # Create JSON format boot metadata
    json_file, ext = os.path.splitext(logfile)
    json_file += ".json"
    boot_json_f = open(json_file, 'w')
    json.dump(boot_meta, boot_json_f, indent=4, sort_keys=True)
    boot_json_f.close()

    sys.exit(retval)

class dummy_expect:
    """ Dummy expect for debug without using real console. """
    class dummy_match:
        def group(self, i):
            return i
    def __init__(self):
        self.match = self.dummy_match()
        self.logfile = None
    def sendline(self, str):
        print str
    def expect(self, exp=None, timeout=0):
        return 0
    def before(self):
        return 'BEFORE'
        
def connect_console():
    """ Spawn and connect to serial console (via conmux). """
    global c, verbose, exp_logfile

    if dry_run:
        c = dummy_expect()
        return

    c = pexpect.spawn("conmux-console vence/%s" %board, timeout=30)
    try:
        fd, exp_logfile = tempfile.mkstemp(prefix="conmux-log-")
        temp_files.append(exp_logfile)
        c.logfile = open(exp_logfile, "w")

    except IOError:
        print 'WARNING: Unable to open %s.  Enabling verbose mode.' %logfile
        verbose = True

    #
    # For interactive use (in addition to logging, connect stdout to
    # logfile_read (logfile_read is used so characters are not echo'd
    # twice)
    #
    if verbose:
        c.logfile_read = sys.stdout 
    try:
        c.expect('Connected to')
    except pexpect.EOF, pexpect.TIMEOUT:
        raise Exception('ERROR: Unable to connect to console.  Giving up.')

    c.sendline('')
    progress('console: connected.')

def sendline(str):
    global c
    c.sendline(str)

def command(str, exp=None, timeout=-1):
    global prompt

    if debug:
        progress('cmd: %s' % str)
    sendline(str)
    try:
        c.expect(exp or prompt, timeout=timeout)
    except pexpect.TIMEOUT:
        raise Exception('ERROR: Timeout waiting for command: %s.' %str)

def boot_to_uboot():
    global prompt, post_reset_ctrl
    
    breakin = False
    while not breakin:
        c.sendline('~$hardreset')

        # Send "post_reset_ctrl" character as a control character right after reset
        if post_reset_ctrl:
            time.sleep(4)
            progress("console: send post_reset_ctrl: %s" %post_reset_ctrl)
            for ch in post_reset_ctrl:
                c.sendcontrol(ch)

        # Break into u-boot
        i = c.expect(['stop autoboot:',
                      'HELLO! BOOT0 is starting',
                      'fastboot: processing commands',
                      'Nokia OMAP Loader',
                      pexpect.TIMEOUT])
        if i == 0:
            breakin = True
        elif i == 1:
            progress('u-boot: HACK: Cubie: old, on-chip bootloader detected.  Resetting again.')
            continue
        elif i == 2:
            progress('u-boot: fastboot mode detected.')
            return
        elif i == 3:
            progress('u-boot: Nokia OMAP Loader (NOLO) detected.')
            return
        else:
            raise Exception('ERROR: Could not break into u-boot.', 'OFFLINE')

    c.sendline('\r')
    progress('u-boot: taking control.')

    # Find u-boot prompt
    try:
        c.expect('[-\w ]*[>#\$]')
    except pexpect.TIMEOUT:
        raise Exception('ERROR: Could not find u-boot prompt.', 'OFFLINE')

    prompt = c.match.group(0)
    if prompt.endswith('$'):
        prompt = prompt[:-1] + "\$"

def init_uboot_env():
    """ Initialize default u-boot env, including values from config file."""
    global prompt

    # Send this command one char at time
    if uboot_early:
        for ch in uboot_early:
            c.send(ch)
        c.send("\n")

    c.expect(prompt)
    command('version')

    # environment values from config file
    if uboot_env:
        uboot_vars = uboot_env.split('\n')
        uboot_vars = filter(None, uboot_vars) # remove empty items, blank lines...
        for var in uboot_vars:
            (key, val) = var.split('=', 1)
            command('setenv %s %s' %(key, val))

    command('if test -n ${initenv}; then run initenv; fi')
    command('if test -n ${preboot}; then run preboot; fi')

def init_net():
    global prompt
    retries = 3

    command('setenv autoload no; setenv autoboot no')
    while retries and dhcp:
        sendline("dhcp")
        i = c.expect(["DHCP client bound",
                      "Unknown command",
                      "Retry count exceeded",
                      pexpect.TIMEOUT],
                     timeout = 30)
        if i == 0:
            progress('u-boot: got DHCP address.')
            c.expect(prompt)
            break;
        elif i == 1:
            raise Exception('u-boot: does not support DHCP.  Giving up.')
        elif i == 2:
            raise Exception('u-boot: ERROR: DHCP retry count exceeded.')
        else:
            retries = retries - 1
            if retries:
                progress('u-boot: DHCP timeout. Trying again (retries=%d)' \
                             %retries)
            else:
                raise Exception('u-boot: ERROR: timeout getting DHCP address.')

    if serverip:
        command('setenv serverip %s' %serverip)

    command("if test -n ${netargs}; then run netargs; fi")

def fastboot_image(kernel, dtb, initrd):
    progress('u-boot: entering fastboot mode.')
    command('printenv bootargs')
    c.sendline('fastboot')

    # The rest of the fastboot magic here is hidden by conmux
    progress('fastboot: loading %s, %s, %s' % (kernel, dtb, initrd))
    c.sendline('~$fastboot %s %s %s' % (kernel, dtb, initrd))

def load_image(file, addr):
    global prompt
    retries = 3

    if serverip:
        file = "%s:%s" %(serverip, file)

    progress('u-boot: TFTP %s to %s' %(file, addr))
    while retries:
        sendline('tftp %s %s' %(addr, file))
        retries = retries - 1
        i = c.expect(['Bytes transferred', 
                      'TFTP error',
                      'Retry count exceeded',
                      pexpect.TIMEOUT],
                     timeout=30)
        if (i == 0):
            c.expect(prompt)
            break
        if (i == 1):
            raise Exception('ERROR: TFTP error.')
        else:
            if retries:
                progress('u-boot: timeout loading %s, Trying again.' %file)
                c.send('\003')  # Ctrl-C: abort current tftp
                c.expect(prompt)
            else:
                raise Exception('ERROR: Timeout loading %s.  Giving up.' %file)

def boot_kernel():
    global prompt, initrd_addr

    boot_cmd='bootm'
    if os.path.basename(kimage)[0] == 'z':
        boot_cmd='bootz'

    if cmdline_append:
        command('setenv bootargs ${bootargs} %s' %cmdline_append)

    command('printenv bootargs')

    # Boot the kernel
    sendline('%s %s %s %s' %(boot_cmd, loadaddr, initrd_addr, dtb_addr))
    progress("u-boot: jumping to kernel image")

    # U-boot should tell us quickly that it's starting the kernel
    i = c.expect(['Starting kernel',
                  'Unknown command',
                  'Wrong Image Type for bootm',
                  'Bad Linux ARM zImage magic',
                  pexpect.TIMEOUT],
                 timeout = 10)
    if i == 0:
        # Kernel started normally
        pass
    elif i == 1:
        raise Exception('u-boot: ERROR: does not support command: %s' %boot_cmd)
    elif i == 2:
        raise Exception('u-boot: ERROR: missing (or overwritten) uImage header')
    elif i == 3:
        raise Exception('u-boot: ERROR: Bad Linux ARM zImage magic.' )
    elif i == 4:
        raise Exception('u-boot: ERROR: Kernel did not start.')

    progress('u-boot: started kernel.')

def wait_for_kernel():
    global warnings

    try:
        c.expect(['Booting Linux',
                  'Linux version'], timeout = 30)
    except pexpect.TIMEOUT:
        raise Exception('kernel: ERROR: did not start booting.')

    progress('kernel: started booting.')

    # Look for end of kernel boot, or various failures
    done = False
    while not done:
        pl = ['Freeing unused kernel memory',
              'Freeing init memory',
              'Unable to handle kernel (.*)\r\n',
              'Kernel panic',
              'VFS: Unable to mount root fs',
              '-+\[ cut here \]-+\s+(.*\s+-+\[ end trace (\w*) \]-+)',
              'Unhandled fault',
              pexpect.TIMEOUT]
        i = c.expect(pl, timeout=90)
        if i == 0 or i == 1:  
            # Kernel booted normally
            done = True
        elif i == 2:
            msg = c.match.group(0)
            raise Exception("kernel: %s" %msg)
        elif i == 5:
            warnings += 1
            progress("kernel: boot warning:")
            if not quiet:
                print c.match.group(1)
            continue
        else:
            raise Exception('kernel: ERROR: failed to boot: %s' %pl[i])

    progress('kernel: finished booting, starting userspace.')

def root_shell():
    """ Wait for linux root shell. """
    global prompt

    # Wait for linux root shell
    prompt = "# "
    pl = [prompt,
          "press Enter to activate",  # busybox
          pexpect.TIMEOUT,
          "Kernel panic",
          "Unhandled fault",
    ]
    i = c.expect(pl, timeout=120)
    if i == 0:
        pass
    elif i == 1:
        command('\n')
    elif i == 2:
        raise Exception('userspace: ERROR: Never found root shell')
    else:
        raise Exception('userspace: failed to find root shell: %s' %pl[i])
    
    progress("userspace: at root shell")

def userspace_info():
    global prompt, kernelversion

    command('cat /proc/cmdline')
    progress('userspace: Kernel command line: %s' %c.before.split('\n')[-2])

    command('uname -r')

    kernelversion = c.before.split('\n')[-2]
    progress('userspace: found kernel version: %s' % kernelversion)

    command('cat /proc/cpuinfo')
    for line in c.before.split('\n'):
        match = re.match('Hardware\s+:\s+(.+)\r', line)
        if match:
            progress('userspace: Hardware: %s' %match.group(1))

def check_errors_warnings():
    # "dmesg -l" requires "real" dmesg, not busybox dmesg
    command('DMESG=$(readlink -f /bin/dmesg)')
    command('[[ $DMESG = "/bin/dmesg" ]] && dmesg -l warn | awk \'{ print "[WARN] " $0 }\'')
    command('[[ $DMESG = "/bin/dmesg" ]] && dmesg -l err | awk \'{ print "[ERR] " $0 }\'')
    # or, on busybox, just check for kern.err, kern.warn in /var/log/messages
    command('[[ -e /var/log/messages ]] && grep kern.warn /var/log/messages | awk \'{ print "[WARN] " $0 }\'')
    command('[[ -e /var/log/messages ]] && grep kern.err /var/log/messages | awk \'{ print "[ERR] " $0 }\'')

def run_test(test, cmd):
    timeout = 1200

    progress('test: %s: %s' %(test, cmd), log=True)
    command(cmd, timeout=timeout)
    command('echo $?')
    retval = int(c.before.split('\n')[-2])
    if retval == 0:
        pass_fail = 'PASS'
    else:
        pass_fail = 'FAIL'
        
    progress("test: %s: returned %d: %s"  %(test, retval, pass_fail), log=True)
    
def do_tests():
    # Board-specific tests
    for o in config.options(section):
        if o.startswith('test_'):
            test = o[5:] # drop 'test_' prefix from test name
            cmd = config.get(section, o)
            run_test(test, cmd)

    # Tests defined in [test] section
    if not config.has_section('test'):
        return

    tests = config.options('test')
    for test in tests:
        # ignore options from DEFAULTS section
        if config.defaults().has_key(test):
            continue
        cmd = config.get('test', test)
        run_test(test, cmd)

def poweroff():
    global c
    c.sendline('~$off')

def dtb_insert_initrd(dtb, initrd_addr):
    """ Insert initrd start/end addresses into DTB.
    
    NOTE: we could use fdtput for this but the original DTB needs to have
    enough padding in it for the new commandline, which is not guaranteed.
    """
    global initrd_cmdline

    # de-compile DTB into temp DTS
    fd, tmp_dts = tempfile.mkstemp(suffix=".dts")
    os.close(fd)
    cmd = "dtc -q -I dtb -O dts -o %s %s > /dev/null 2>&1" %(tmp_dts, dtb)
    subprocess.call(cmd, shell=True)

    initrd_start = int(initrd_addr, 16)
    initrd_end = initrd_start + initrd_size
    chosen_frag = "/ { chosen { linux,initrd-start = <0x%08x>; linux,initrd-end = <0x%08x>; }; };\n" %(initrd_start, initrd_end)
    fp = open(tmp_dts, 'a')
    fp.write(chosen_frag)
    fp.close()
    initrd_cmdline = True

    # Re-compile DTS into new DTB
    fd, dtb_modified = tempfile.mkstemp(suffix=".dtb")
    os.close(fd)
    cmd = "dtc -I dts -O dtb -o %s %s > /dev/null 2>&1" %(dtb_modified, tmp_dts)
    subprocess.call(cmd, shell=True)
    os.unlink(tmp_dts)
    os.chmod(dtb_modified, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)

    print "DTB: new/modified DTB: %s" %dtb_modified
    return dtb_modified

def initrd_add_uboot_header(initrd):
    """Add u-boot initrd header so it can be booted using u-boot bootm/bootz."""
    global initrd_uboot_tmp

    basename = os.path.basename(initrd)
    fd, initrd_uboot_tmp = tempfile.mkstemp(prefix=basename, suffix=".uboot")
    os.close(fd)
    cmd = "mkimage -A arm -O linux -T ramdisk -C none -a 0 -e 0 -n %s -d %s %s > /dev/null" %(basename, initrd, initrd_uboot_tmp)
    subprocess.call(cmd, shell=True)
    if os.path.exists(initrd_uboot_tmp):
        print("initrd: Added u-boot header.  Modified initrd: %s" %initrd_uboot_tmp)
        os.chmod(initrd_uboot_tmp, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)
        initrd_size = os.path.getsize(initrd_uboot_tmp)
        return initrd_uboot_tmp
    else:
        raise Exception("Unable to add u-boot header to initrd %s" %initrd)

def zimage_hack_endian(kimage):
    zimage_magic_offset = 0x24
    zimage_magic = 0x016f2818
    magic_hack = struct.pack("<L", zimage_magic)  # ensure LE

    fd, zimage_hack = tempfile.mkstemp(prefix="zImage-hack-")
    os.close(fd)
    shutil.copyfile(kimage, zimage_hack)

    fp = open(zimage_hack, 'r+')
    fp.seek(zimage_magic_offset)
    fp.write(magic_hack)
    fp.close()
    print "zImage: HACK: forcing little-endian magic number in %s" %zimage_hack
    return zimage_hack

sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0) # Unbuffer output
start_time = time.time()

if endian == "big":
    kimage = zimage_hack_endian(kimage)

if dtb and initrd_addr and not initrd_uboot:
    dtb = dtb_insert_initrd(dtb, initrd_addr)

if dtb and dtb_append:
    fd, kimage_appended = tempfile.mkstemp(prefix="zImage-dtb-")
    subprocess.call('cat %s %s > %s' \
                        %(kimage, dtb, kimage_appended), shell=True)
    os.chmod(kimage_appended, stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH)
    kimage = kimage_appended

boot_meta["kernel_image"] = kimage
boot_meta["loadaddr"] = loadaddr
if initrd:
    boot_meta["initrd_addr"] = initrd_addr
if dtb:
    boot_meta["dtb"] = dtb
    if dtb_append:
        boot_meta["dtb_append"] = True
    else:
        boot_meta["dtb_addr"] = dtb_addr

if convert_uimage:
    kimage = create_uimage(kimage, uimage_addr)
    boot_meta["uImage"] = True
    boot_meta["uimage_addr"] = uimage_addr

if (initrd and not dtb) or initrd_uboot:
    initrd = initrd_add_uboot_header(initrd)

tftp_setup()
kimage = tftp_relpath(kimage)
if dtb:
    dtb = tftp_relpath(dtb)
if initrd:
    initrd = tftp_relpath(initrd)

try:
    connect_console()
    boot_to_uboot()
    init_uboot_env()

    if fastboot:
        fastboot_image(kimage, dtb, initrd)
    else:
        if not dry_run:
            init_net()

        load_image(kimage, loadaddr)
        if initrd:
            load_image(initrd, initrd_addr)
            if initrd_cmdline:
                initrd_addr = "-"
        if dtb and not dtb_append:
            load_image(dtb, dtb_addr)
            if not initrd:
                initrd_addr = '-'  # needed for bootm/bootz if dtb present

        boot_kernel()

    if interact:
        progress('userspace: going interactive.  Use escape char (^]) to exit.')
        c.interact()
        do_report(0)
    else:
        wait_for_kernel()

    root_shell()
    if not dry_run:
        userspace_info()

    if check_warnings:
        check_errors_warnings()

    if run_tests:
        do_tests()

    if shutdown:
        progress('userspace: shutting down')
        c.sendline('halt')
        time.sleep(1)
        poweroff()

    do_report(0)

except Exception as e:
    # ensure we read any remaining input
    c.expect([pexpect.EOF, pexpect.TIMEOUT], timeout=1)
    progress('got exception: %s' % e)
    poweroff()
    if c.logfile:
        c.logfile.write('# PYBOOT: Exception: %s\n' %e)

    # e.args[0] is message, e.args[1] (if present) is result code
    if len(e.args) > 1:
        do_report(1, e.args[1])  # pass result 
    else:
        do_report(1)

finally:
    if c.logfile:
        c.logfile.close()

    # remove non-printable chars (and \r) from temp output log, and save to final location
    cmd = "tr -dc \'[:print:]\n\' < %s > %s" %(exp_logfile, logfile)
    subprocess.call(cmd, shell=True)

    tftp_cleanup()
    if dtb_modified:
        os.unlink(dtb_modified)
    if initrd_uboot_tmp:
        os.unlink(initrd_uboot_tmp)
    for f in temp_files:
        if (os.path.exists(f)):
            os.unlink(f)

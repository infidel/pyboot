#!/usr/bin/env python
#
# pyboot: automatically load/boot kernel + DTB + initrd
#
# Automatically load and boot kernel image (and optionally load DTB
# and initrd) on <board> using netboot (DHCP + TFTP).  Images are
# copied to a temporary, TFTP-accessible location (unless already
# under TFTP root dir) so they can be loaded by <board> via TFTP.
# 
# Serial console and hardreset/power-down of <board> is handled
# through conmux.  Conmux provides the serial console, and also allows
# special escape that can run arbitrary commands and are useful for
# hardreset and power-off of target board.
#
# Reads config file from /etc/pyboot.conf, $PWD/.pyboot and ~/.pyboot
#
# Authors: Olof Johansson <olof@lixom.net>, Kevin Hilman <khilman@kernel.org>
#
# This file is licensed under the terms of the GNU General Public
# License version 2. This program is licensed "as is" without any
# warranty of any kind, whether express or implied.
#
import os, sys, time, stat, re
import pexpect, getopt, tempfile, shutil, subprocess
import ConfigParser

def usage():
    name = os.path.basename(sys.argv[0])
    print
    print name, "[options] <board> [<kernel>[:addr]] [<dtb>[:addr]] [<initrd>[:addr]"
    print "  -h: this help message"
    print "  -d: enable debug mode"
    print "  -v: display verbose interaction with target"
    print "  -i: after kernel boots, enter interactive mode with serial console"
    print "  -u <addr>: create uImage from zImage with <addr> as load address"
    print "             (useful when u-boot is missing bootz support)"
    print "  -c <cmdline>: append on to kernel commandline"
    print "  -t: run tests defined in config file"
    print

verbose = False
interact = False
convert_uimage = False
shutdown = False  # shutdown/halt and poweroff board when done
cmdline_append = ""
debug = False
dry_run = False
quiet = False
prompt = ''
logfile = None
run_tests = False

try:
    opts, args = getopt.getopt(sys.argv[1:], "c:dhil:qstu:vy")

except getopt.GetoptError as err:
    print str(err) # will print something like "option -a not recognized"
    sys.exit(2)
for o, a in opts:
    if o == "-c":
        cmdline_append = a
    elif o == "-d":
        debug = True
    elif o == "-y":
        dry_run = True
    elif o == "-h":
        usage()
        sys.exit(0)
    elif o == "-i":
        interact = True
    elif o == "-l":
        logfile = a
    elif o == "-s":
        shutdown = True
    elif o == "-q":
        quiet = True
    elif o == "-t":
        run_tests = True
    elif o == "-u":
        convert_uimage = True
        uimage_addr = a
    elif o == "-v":
        verbose = True
    else:
        assert False, "unhandled option %s" %o
 
if len(args) < 1:
    usage()
    sys.exit(1)

board = args[0]
tftproot = '/tftpboot'
serverip = None
loadaddr = None
dtb = None
dtb_addr = None
dtb_append = None
initrd = None
initrd_addr = None
uboot_env = None
log_prefix = 'boot-%s' %board
if not logfile:
    logfile = "%s.log" %log_prefix
start_time = 0
boot_time = 0


config = ConfigParser.ConfigParser()
config.read(['/etc/pyboot.conf', os.path.expanduser('~/.pyboot'), '.pyboot'])

section = 'DEFAULT'
if config.has_section(board):
    section = board

if debug:
    for item in config.items(section):
        print item

# Config file options
if config.has_option(section, 'serverip'):
    serverip = config.get(section, 'serverip')
if config.has_option(section, 'tftproot'):
    tftproot = config.get(section, 'tftproot')
if config.has_option(section, 'image'):
    kimage = config.get(section, 'image')
if config.has_option(section, 'dtb'):
    dtb = config.get(section, 'dtb')
if config.has_option(section, 'initrd'):
    initrd = config.get(section, 'initrd')
if config.has_option(section, 'uboot_env'):
    uboot_env = config.get(section, 'uboot_env')
if config.has_option(section, 'uimage_addr'):
    uimage_addr = config.get(section, 'uimage_addr')
    convert_uimage = True

if len(args) > 1:
    kimage = args[1]
if len(args) > 2:
    dtb = args[2]
if len(args) > 3:
    initrd = args[3]

def path_addr_split(path):
    """Split the argument (of the form path[:addr] into (path, addr)"""
    addr = None
    if path == '-':
        return (None, None)
    if path.find(':') != -1:
        (path, addr) = path.split(':')
    if not os.path.exists(path):
        print "ERROR: file", path, "does not exist."
        sys.exit(1)
    return (path, addr)

(kimage, loadaddr) = path_addr_split(kimage)
if not loadaddr:
    if config.has_option(section, 'loadaddr'):
        loadaddr = config.get(section, 'loadaddr')
    else:
        loadaddr = '${loadaddr}' # use u-boot env 
if dtb:
    (dtb, dtb_addr) = path_addr_split(dtb)
    if not dtb_addr:
        if config.has_option(section, 'dtb_append'):
            dtb_append = True
            dtb_addr = ''
        elif config.has_option(section, 'dtb_addr'):
            dtb_addr = config.get(section, 'dtb_addr')
        else:
            dtb_addr = '${fdtaddr}' # use u-boot env
if not dtb:
    dtb_addr = ''

if initrd:
    (initrd, initrd_addr) = path_addr_split(initrd)
    if not initrd_addr:
        if config.has_option(section, 'initrd_addr'):
            initrd_addr = config.get(section, 'initrd_addr')
        else:
            initrd_addr = '${initrdaddr}' # use u-boot env
if not initrd:
    initrd_addr = ''

if not quiet:
    print "Board:", board
    print "Kernel:", kimage, loadaddr
    if initrd:
        print "initrd:", initrd, initrd_addr
    if dtb:
        print "DTB:", dtb, 
        if dtb_append:
            print "(appending to kernel image)"
        else:
            print dtb_addr

def progress(str, log=False):
    global start_time, c
    if dry_run:
        return

    t = time.time() - start_time
    min = t / 60
    sec = t % 60
    timestamp = '[%02d:%02d]' %(min, sec)

    if log and c.logfile:
        c.logfile.write("\n# PYBOOT: %s\n" %str)

    if verbose:
        # target console output is already verbose enough, don't add to it
        return

    if not quiet:
        print '%s %s' %(timestamp, str)

def create_uimage(zimg, addr):
    """ Create uImage from zImage with @addr ad load address. """
    if not os.path.basename(zimg).startswith('z'):
        raise Exception('ERROR: need a zImage to create a uImage: %s' %zimg)

    fd, uimg = tempfile.mkstemp(suffix="-uImage")
    cmd = 'mkimage -A arm -O linux -T kernel -C none -a %s -e %s -n "Linux" -d %s %s > /dev/null' %(addr, addr, zimg, uimg)
    subprocess.call(cmd, shell=True)
    os.chmod(uimg, stat.S_IRWXU | stat.S_IRGRP | stat.S_IROTH)
    if not os.path.exists(uimg):
        raise Exception('Unable to create uImage.')
    else:
        progress("Convered zImage to uImage (load address = %s)" %uimage_addr)

    return uimg

def tftp_setup():
    """ Create temp TFTP location. """
    global tftpdir, tftprel

    tftptmp = os.path.join(tftproot, 'tmp')
    if not os.path.exists(tftptmp):
        os.mkdir(tftptmp)
    tftpdir = tempfile.mkdtemp(prefix='%s-' %board, dir=tftptmp)
    os.chmod(tftpdir, stat.S_IRWXU | stat.S_IXGRP | stat.S_IXOTH)
    tftprel = os.path.relpath(tftpdir, tftproot)

def tftp_relpath(path):
    """Copy file into tftproot for access via TFTP and return path.
    If path is already under tftproot, do not copy, just return
    relative path.
    """
    global tftpdir, tftprel

    if path.startswith(tftproot):
        # already in TFTP root, no need to copy, just drop TFTP root prefix
        path = path[len(tftproot)+1:]  
    else:
        shutil.copy(path, tftpdir)
        path = os.path.join(tftprel, os.path.basename(path))
        
    return path

def tftp_cleanup():
    global tftpdir

    if tftpdir:
        shutil.rmtree(tftpdir)
        tftpdir = None

def do_report(retval=0):
    global start_time, c

    boot_time = time.time() - start_time
    if retval:
        result = 'FAIL'
    else:
        result = 'PASS'
    if not quiet:
        print "# PYBOOT: Time: %.2f" %boot_time
        print "# PYBOOT: Result: %s" %result

    if c.logfile:
        c.logfile.write("# PYBOOT: Time: %.2f seconds.\n" %boot_time)
        c.logfile.write("# PYBOOT: Result: %s\n" %result)
    sys.exit(retval)

class dummy_expect:
    """ Dummy expect for debug without using real console. """
    class dummy_match:
        def group(self, i):
            return i
    def __init__(self):
        self.match = self.dummy_match()
        self.logfile = None
    def sendline(self, str):
        print str
    def expect(self, exp=None, timeout=0):
        return 0
    def before(self):
        return 'BEFORE'
        
def connect_console():
    """ Spawn and connect to serial console (via conmux). """
    global c, verbose

    if dry_run:
        c = dummy_expect()
        return

    c = pexpect.spawn("conmux-console vence/%s" %board, timeout=30)
    try:
        c.logfile = open(logfile, 'w')
    except IOError:
        print 'WARNING: Unable to open %s.  Enabling verbose mode.' %logfile
        verbose = True

    #
    # For interactive use (in addition to logging, connect stdout to
    # logfile_read (logfile_read is used so characters are not echo'd
    # twice)
    #
    if verbose:
        c.logfile_read = sys.stdout 
    try:
        c.expect('Connected to')
    except pexpect.EOF, pexpect.TIMEOUT:
        raise Exception('ERROR: Unable to connect to console.  Giving up.')

    c.sendline('')
    progress('console: connected.')

def command(str, exp=None, timeout=-1):
    global prompt

    if debug:
        progress('cmd: %s' % str)
    c.sendline(str)
    try:
        c.expect(exp or prompt, timeout=timeout)
    except pexpect.TIMEOUT:
        raise Exception('ERROR: Timeout waiting for command: %s.' %str)

def boot_to_uboot():
    global prompt
    
    breakin = False
    while not breakin:
        c.sendline('~$hardreset')

        # Break into u-boot
        i = c.expect(['stop autoboot:',
                      'HELLO! BOOT0 is starting',
                      pexpect.TIMEOUT])
        if i == 0:
            breakin = True
        elif i == 1:
            progress('u-boot: HACK: Cubie: old, on-chip bootloader detected.  Resetting again.')
            continue
        elif i == 2:
            raise Exception('ERROR: Could not break into autoboot.')

    c.sendline('\r')
    progress('u-boot: taking control.')

    # Find u-boot prompt
    try:
        c.expect('[-\w ]*[>#\$]')
    except pexpect.TIMEOUT:
        raise Exception('ERROR: Could not break into autoboot.')

    prompt = c.match.group(0)
    if prompt.endswith('$'):
        prompt = prompt[:-1] + "\$"

    c.expect(prompt)
    command('version')

def init_uboot_env():
    global prompt

    """ Initialize default u-boot env, including values from config file."""

    # environment values from config file
    if uboot_env:
        uboot_vars = uboot_env.split('\n')
        uboot_vars = filter(None, uboot_vars) # remove empty items, blank lines...
        for var in uboot_vars:
            (key, val) = var.split('=', 1)
            command('setenv %s %s' %(key, val))

    command('if test -n ${initenv}; then run initenv; fi')
    command('if test -n ${preboot}; then run preboot; fi')

def init_net():
    global prompt
    retries = 3

    command('setenv autoload no; setenv autoboot no')
    while retries:
        c.sendline("dhcp")
        i = c.expect(["DHCP client bound",
                      "Unknown command",
                      "Retry count exceeded",
                      pexpect.TIMEOUT],
                     timeout = 30)
        if i == 0:
            progress('u-boot: got DHCP address.')
            break
        elif i == 1:
            raise Exception('u-boot: does not support DHCP.  Giving up.')
        elif i == 2:
            raise Exception('u-boot: ERROR: DHCP retry count exceeded.')
        else:
            retries = retries - 1
            if retries:
                progress('u-boot: DHCP timeout. Trying again (retries=%d)' \
                             %retries)
            else:
                raise Exception('u-boot: ERROR: timeout getting DHCP address.')

    c.expect(prompt)
    if serverip:
        c.sendline('setenv serverip %s' %serverip)
        c.expect(prompt)

    c.sendline("if test -n ${netargs}; then run netargs; fi")
    c.expect(prompt)

def load_image(file, addr):
    global prompt
    retries = 3

    if serverip:
        file = "%s:%s" %(serverip, file)

    progress('u-boot: TFTP %s to %s' %(file, addr))
    while retries:
        c.sendline('tftp %s %s' %(addr, file))
        retries = retries - 1
        i = c.expect(['Bytes transferred', 
                      'TFTP error',
                      'Retry count exceeded',
                      pexpect.TIMEOUT],
                     timeout=30)
        if (i == 0):
            c.expect(prompt)
            break
        if (i == 1):
            raise Exception('ERROR: TFTP error.')
        else:
            if retries:
                progress('u-boot: timeout loading %s, Trying again.' %file)
                c.send('\003')  # Ctrl-C: abort current tftp
                c.expect(prompt)
            else:
                raise Exception('ERROR: Timeout loading %s.  Giving up.' %file)

def boot_kernel():
    global prompt

    boot_cmd='bootm'
    if os.path.basename(kimage)[0] == 'z':
        boot_cmd='bootz'

    if cmdline_append:
        command('setenv bootargs ${bootargs} %s' %cmdline_append)

    command('printenv bootargs')

    # Boot the kernel
    c.sendline('%s %s %s %s' %(boot_cmd, loadaddr, initrd_addr, dtb_addr))
    progress("u-boot: jumping to kernel image")

    # U-boot should tell us quickly that it's starting the kernel
    i = c.expect(['Starting kernel',
                  'Unknown command',
                  'Wrong Image Type for bootm',
                  pexpect.TIMEOUT],
                 timeout = 10)
    if i == 0:
        # Kernel started normally
        pass
    elif i == 1:
        raise Exception('u-boot: ERROR: does not support command: %s' %boot_cmd)
    elif i == 2:
        raise Exception('u-boot: ERROR: missing (or overwritten) uImage header')
    elif i == 3:
        raise Exception('u-boot: ERROR: Kernel did not start.')

    progress('u-boot: started kernel.')

def wait_for_kernel():
    try:
        c.expect(['Booting Linux',
                  'Linux version'], timeout = 10)
    except pexpect.TIMEOUT:
        raise Exception('kernel: ERROR: did not start booting.')

    progress('kernel: started booting.')

    # Look for end of kernel boot, or various failures
    pl = ['Freeing unused kernel memory',
          'Unable to handle kernel (.*)\r\n',
          'Kernel panic',
          'VFS: Unable to mount root fs',
          pexpect.TIMEOUT]
    i = c.expect(pl, timeout=60)
    if i == 0: 
        # Kernel booted normally
        pass
    elif i == 1:
        msg = c.match.group(0)
        raise Exception("kernel: %s" %msg)
    else:
        raise Exception('kernel: ERROR: failed to boot: %s' %pl[i])

    progress('kernel: finished booting, starting userspace.')

def root_shell():
    """ Wait for linux root shell. """
    global prompt

    # Wait for linux root shell
    prompt = "# "
    i = c.expect([prompt,
                  "press Enter to activate",  # busybox
                  "Kernel panic",
                  pexpect.TIMEOUT],
                 timeout=120)
    if i == 0:
        pass
    elif i == 1:
        command('\n')
    elif i == 2:
        raise Exception('Kernel panic')
    else:
        raise Exception('userspace: ERROR: Never found root shell')
    
    progress("userspace: at root shell")

def userspace_info():
    global prompt, kernelversion

    command('cat /proc/cmdline')
    progress('userspace: Kernel command line: %s' %c.before.split('\n')[-2])

    command('uname -r')

    kernelversion = c.before.split('\n')[-2]
    progress('userspace: found kernel version: %s' % kernelversion)

    command('cat /proc/cpuinfo')
    for line in c.before.split('\n'):
        match = re.match('Hardware\s+:\s+(.+)\r', line)
        if match:
            progress('userspace: Hardware: %s' %match.group(1))

    command('ip -f inet -o addr')
    for line in c.before.split('\n'):
        match = re.match('(\d+):\s+(\w+)\s+(\w+)\s+([0-9.]+)', line)
        if match:
            progress('userspace: interface %s: %s' % (match.group(2), match.group(4)))

def run_test(test, cmd):
    timeout = 1200

    progress('test: %s: %s' %(test, cmd), log=True)
    command(cmd, timeout=timeout)
    command('echo $?')
    retval = int(c.before.split('\n')[-2])
    if retval == 0:
        pass_fail = 'PASS'
    else:
        pass_fail = 'FAIL'
        
    progress("test: %s: returned %d: %s"  %(test, retval, pass_fail), log=True)
    
def do_tests():
    # Board-specific tests
    for o in config.options(section):
        if o.startswith('test_'):
            test = o[5:] # drop 'test_' prefix from test name
            cmd = config.get(section, o)
            run_test(test, cmd)

    # Tests defined in [test] section
    if not config.has_section('test'):
        return

    tests = config.options('test')
    for test in tests:
        # ignore options from DEFAULTS section
        if config.defaults().has_key(test):
            continue
        cmd = config.get('test', test)
        run_test(test, cmd)

def poweroff():
    global c
    c.sendline('~$off')

sys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0) # Unbuffer output
start_time = time.time()

if dtb and dtb_append:
    fd, kimage_appended = tempfile.mkstemp(prefix="zImage")
    subprocess.call('cat %s %s > %s' \
                        %(kimage, dtb, kimage_appended), shell=True)
    kimage = kimage_appended

if convert_uimage:
    kimage = create_uimage(kimage, uimage_addr)

tftp_setup()
kimage = tftp_relpath(kimage)
if dtb:
    dtb = tftp_relpath(dtb)
if initrd:
    initrd = tftp_relpath(initrd)

try:
    connect_console()
    boot_to_uboot()
    init_uboot_env()
    if not dry_run:
        init_net()

    load_image(kimage, loadaddr)
    if initrd:
        load_image(initrd, initrd_addr)
    if dtb and not dtb_append:
        load_image(dtb, dtb_addr)
        if not initrd:
            initrd_addr = '-'  # needed for bootm/bootz if dtb present

    boot_kernel()

    if interact:
        progress('userspace: going interactive.  Use escape char (^]) to exit.')
        c.interact()
        do_report(0)
    else:
        wait_for_kernel()

    root_shell()
    if not dry_run:
        userspace_info()

    if run_tests:
        do_tests()

    if shutdown:
        progress('userspace: shutting down')
        c.sendline('halt')
        time.sleep(1)
        poweroff()

    do_report(0)

except Exception as e:
    # ensure we read any remaining input
    c.expect([pexpect.EOF, pexpect.TIMEOUT], timeout=1)
    progress('got exception: %s' % e)
    poweroff()
    if c.logfile:
        c.logfile.write('# PYBOOT: Exception: %s\n' %e)
    do_report(1)

finally:
    if c.logfile:
        c.logfile.close()
    # remove all the \r from the expect log (perl is better for this ;)
    subprocess.call("perl -pi -e 's/\r//g' %s" %logfile, shell=True)
    tftp_cleanup()
